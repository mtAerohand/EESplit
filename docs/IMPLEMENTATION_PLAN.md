# EESplit 実装計画

## 実装の全体方針

### 段階的な実装アプローチ
機能を段階的に実装し、各段階でテストと検証を行う。

### 優先順位
1. **Phase 1**: データ構造の拡張（精鋭数フィールドの追加）
2. **Phase 2**: UI機能の実装（精鋭数設定、カウンター表示）
3. **Phase 3**: 計算・表示機能（平均討伐秒数）
4. **Phase 4**: 高度な機能（色分け表示、閾値設定）

---

## Phase 1: データ構造の拡張

### 目的
livesplit-core（Rust）とフロントエンド（TypeScript）のデータ構造に精鋭数フィールドを追加

### 実装タスク

#### 1.1 Rustコア（livesplit-core）
- [ ] Segmentデータ構造に `elite_count` フィールドを追加
- [ ] Run保存/読み込み時に精鋭数を永続化
- [ ] 後方互換性の確保（既存ファイルを読み込んだ際のデフォルト値: 0）

**対象ファイル**（予想）:
- `livesplit-core/src/run/segment.rs`
- `livesplit-core/src/run/parser/` 内の関連ファイル

#### 1.2 TypeScript型定義
- [ ] Segment型に `eliteCount` フィールドを追加
- [ ] Run型の更新

**対象ファイル**（予想）:
- `src/livesplit-core/` 内の型定義ファイル

### 検証方法
- 精鋭数を含むRunを保存し、再度読み込んで正しく復元されることを確認
- 既存のLiveSplitファイルを読み込んでエラーが出ないことを確認

---

## Phase 2: UI機能の実装

### 目的
ユーザーが精鋭数を設定し、カウンターを表示できるようにする

### 実装タスク

#### 2.1 スプリット編集UI
- [ ] スプリット編集ダイアログに「精鋭数」入力フィールドを追加
- [ ] 数値検証（0以上の整数のみ受け付ける）
- [ ] UIのローカライズ（日本語対応）

**対象ファイル**（予想）:
- `src/ui/SegmentEditor.tsx` または類似のコンポーネント
- `src/locale/` 内のローカライゼーションファイル

#### 2.2 精鋭数カウンター表示
- [ ] メイン画面上部に「現在の合計/全区間の合計」を表示するコンポーネントを作成
- [ ] 完了した区間の精鋭数を集計する計算ロジック
- [ ] 全区間の精鋭数合計を計算する機能

**対象ファイル**（予想）:
- `src/ui/` に新規コンポーネント `EliteCounter.tsx` を作成
- メインレイアウトコンポーネントにカウンターを配置

#### 2.3 合計表示（設定画面）
- [ ] スプリット一覧画面に全区間の精鋭数合計を表示
- [ ] リアルタイムで合計を更新

**対象ファイル**（予想）:
- `src/ui/RunEditor.tsx` または類似のコンポーネント

### 検証方法
- スプリット編集画面で精鋭数を設定できることを確認
- カウンターが正しい値を表示することを確認
- スプリット完了時にカウンターが更新されることを確認

---

## Phase 3: 計算・表示機能

### 目的
区間ごとの平均討伐秒数を計算し、表示する

### 実装タスク

#### 3.1 平均討伐秒数の計算
- [ ] 区間完了時に平均秒数を計算する関数を実装
- [ ] 計算式: `区間タイム（秒） ÷ 精鋭数`
- [ ] エッジケース処理:
  - 精鋭数が0の場合: "N/A" と表示
  - 区間タイムが0の場合: "N/A" と表示

**実装場所**:
- ユーティリティ関数として実装（例: `src/util/eliteCalculations.ts`）

#### 3.2 スプリット一覧への列追加
- [ ] スプリット一覧コンポーネントに「平均秒/体」列を追加
- [ ] 区間完了後のみ表示（進行中は空白または "-"）
- [ ] 表示形式: 小数点1桁（例: "8.5秒/体"）

**対象ファイル**（予想）:
- `src/ui/SplitsView.tsx` または類似のコンポーネント
- `src/ui/Split.tsx` などの個別スプリットコンポーネント

### 検証方法
- 様々な精鋭数・タイムの組み合わせで正しく計算されることを確認
- エッジケース（0除算など）が適切に処理されることを確認
- 表示フォーマットが仕様通りであることを確認

---

## Phase 4: 高度な機能

### 目的
パフォーマンス悪化区間を視覚的に識別できるようにする

### 実装タスク

#### 4.1 設定画面の実装
- [ ] 閾値設定UIを追加
  - [ ] ラジオボタン: 下位n%、下位n位、討伐平均秒数
  - [ ] 数値入力フィールド
  - [ ] デフォルト値の設定
- [ ] 設定の保存・読み込み

**対象ファイル**（予想）:
- `src/ui/SettingsEditor.tsx` または類似のコンポーネント
- `src/settings/` 内の設定管理ファイル

#### 4.2 判定ロジックの実装
- [ ] 現在のラン内で各区間の平均討伐秒数を比較
- [ ] 選択された閾値オプションに基づいて判定:
  1. **下位n%**: 全区間をソートし、下位n%に該当する区間を判定
  2. **下位n位**: 全区間をソートし、下位n位の区間を判定
  3. **討伐平均秒数**: 絶対値で指定秒数以上の区間を判定

**実装場所**:
- ユーティリティ関数として実装（例: `src/util/performanceAnalysis.ts`）

#### 4.3 色分け表示の実装
- [ ] 判定結果に基づいてスプリット行のスタイルを変更
- [ ] 固定色の定義:
  - 背景色: `#ff4444`（赤系）
  - テキスト色: `#ffffff`（白）
- [ ] テーマシステムとの統合（既存のテーマ機能と調和させる）

**対象ファイル**（予想）:
- `src/ui/Split.tsx` などのスプリットコンポーネント
- `src/css/` 内のスタイルファイル

### 検証方法
- 各閾値オプションが正しく機能することを確認
- 色分けが視覚的に明確で読みやすいことを確認
- 設定が保存・復元されることを確認

---

## 技術的な考慮事項

### コードベースの理解
実装前に以下を調査・理解する必要がある:

1. **livesplit-core（Rust）の構造**
   - Segment/Run データ構造
   - シリアライゼーション/デシリアライゼーション
   - Rustからwasmへのバインディング

2. **フロントエンド（React + TypeScript）の構造**
   - コンポーネント階層
   - 状態管理（Redux/Context/その他）
   - livesplit-coreとのインターフェース

3. **既存のUI/UXパターン**
   - スプリット編集の仕組み
   - 設定管理の仕組み
   - テーマ・スタイリングシステム

### パフォーマンス最適化
- 計算処理は軽量に保つ（スプリット完了時のみ計算）
- 再レンダリングを最小限に抑える
- メモ化（useMemo/useCallback）を適切に使用

### テスト戦略
各Phase完了後に以下をテスト:
- ユニットテスト（計算ロジック）
- 統合テスト（UI操作フロー）
- 手動テスト（実際のRTAシナリオ）

---

## 次のステップ

1. **コードベース探索**
   - 上記の「技術的な考慮事項」を調査
   - 実装対象ファイルを特定
   - 既存のパターンを理解

2. **Phase 1の実装開始**
   - データ構造の拡張から着手
   - 小さく始めて段階的に進める

3. **継続的なテスト**
   - 各変更後に動作確認
   - 既存機能を壊していないことを確認
